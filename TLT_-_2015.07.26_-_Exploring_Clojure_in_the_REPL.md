---
title: TLT_-_2015.07.26_-_Exploring_Clojure_in_the_REPL
createdAt: 2015-07-26T14:49-04:00
editedAt: 2015-07-26T14:51-04:00
---

When I first learned Linux, my friend taught me a few commands. How to to list files, how to change directories and see your current directory, how to run things, how to ask a program what parameters it takes, and how to look at a file (ls, cd, pwd, ./foo or /usr/bin/foo or foo, foo --help, cat foo or more foo). After that I just... ran a lot of stuff. I eventually discovered 'man' -- but going through /bin and running ALL the commands was really educational.

Let's get some basic tools to do that with the Clojure REPL! The major things we want to do are find things (mostly functions), and then learn all about them.

== Finding Things ==

So Clojure has namespaces, which are kinda like directories, using "." as a way to indicate nesting. Vars (and thereby named functions) are kinda like files. So the full "path" to a var looks like "clojure.string/split" where "clojure.string" is the namespace and "split" is the function.

First let's get a list of all the loaded namespaces. The "ns-all" gives us this, but we want a nice sorted printout, so we'll add a bit.
<code clojure-repl>
user=> (doseq [n (sort (map ns-name (all-ns)))] (println n))
bultitude.core
cemerick.pomegranate
cemerick.pomegranate.aether
classlojure.core
clj-stacktrace.core
clj-stacktrace.repl
clj-stacktrace.utils
clojure.core
clojure.core.protocols
clojure.inspector
clojure.instant
clojure.java.browse
clojure.java.io
clojure.java.javadoc
clojure.java.shell
clojure.main
clojure.pprint
clojure.repl
clojure.set
clojure.stacktrace
clojure.string
clojure.template
clojure.test
clojure.tools.cli
clojure.tools.nrepl
clojure.tools.nrepl.ack
clojure.tools.nrepl.bencode
clojure.tools.nrepl.middleware
clojure.tools.nrepl.middleware.interruptible-eval
clojure.tools.nrepl.middleware.load-file
clojure.tools.nrepl.middleware.pr-values
clojure.tools.nrepl.middleware.session
clojure.tools.nrepl.misc
clojure.tools.nrepl.server
clojure.tools.nrepl.transport
clojure.uuid
clojure.walk
clojure.zip
complete.core
dynapath.defaults
dynapath.dynamic-classpath
dynapath.util
leiningen.core.classpath
leiningen.core.eval
leiningen.core.main
leiningen.core.project
leiningen.core.user
leiningen.core.utils
leiningen.repl
leiningen.trampoline
net.cgrand.parsley
net.cgrand.parsley.fold
net.cgrand.parsley.grammar
net.cgrand.parsley.lrplus
net.cgrand.parsley.stack
net.cgrand.parsley.tree
net.cgrand.parsley.util
net.cgrand.regex
net.cgrand.regex.charset
net.cgrand.regex.unicode
net.cgrand.sjacket
net.cgrand.sjacket.parser
pedantic.core
pedantic.node
pedantic.path
reply.completion
reply.conversions
reply.eval-modes.nrepl
reply.eval-modes.shared
reply.eval-modes.standalone
reply.eval-modes.standalone.concurrency
reply.eval-state
reply.exit
reply.exports
reply.hacks.printing
reply.initialization
reply.main
reply.parsing
reply.reader.jline.completion
reply.reader.simple-jline
reply.signals
trptcolin.versioneer.core
useful.java
user
</code>

Use "dir" to look at all the exposed vars from a namespace
<code clojure-repl>
user=> (dir clojure.string)
blank?
capitalize
escape
join
lower-case
re-quote-replacement
replace
replace-first
reverse
split
split-lines
trim
trim-newline
triml
trimr
upper-case
</code>

Search for functions with "split" in their name. There is also "apropos" but it doesn't show namespaces -- "apropos-better" does, and "find-name" is an alias of that, so is better.
<code clojure-repl>
user=> (find-name "split")
(split-at split-with clojure.string/split clojure.string/split-lines net.cgrand.parsley.grammar/split-empty-prods)
</code>

You can also use a regex! Not sure how useful this is... but here we are getting all the functions that start with an "s" and in with a "t".
<code clojure-repl>
user=> (find-name #"^s.*t$")
(set short sort sorted-set spit split-at struct clojure.set/select clojure.string/split clojure.test/set-test net.cgrand.sjacket/shift net.cgrand.sjacket/shift-right net.cgrand.sjacket/str-pt net.cgrand.sjacket/subedit)
</code>

== Learning About Things ==

Once you've found your function, you'll want to learn more about it and maybe give it a try.

"doc" can be used to get the documentation associated with a function. This is pretty cool! It shows the full name of the function, its signature, and it's documentation.
<code clojure-repl>
user=> (doc print)
-------------------------
clojure.core/print
([& more])
  Prints the object(s) to the output stream that is the current value
  of *out*.  print and println produce output for human consumption.
</code>

Note that you can tab-complete
<code clojure-repl>
user=> (doc print<tab>
print          print-ctor     print-dup      print-method   print-simple   print-str
printf         println        println-str
</code>

If you don't know what you're looking for, you can also try find-doc. This will search both the name and the documentation itself for your string or regex.
<code clojure-repl>
user=> (find-doc "split")
; ..... too long to include ;)
</code>

THE ULTIMATE: Get the source for a function!
<code clojure-repl>
user=> (source print)
(defn print
  "Prints the object(s) to the output stream that is the current value
  of *out*.  print and println produce output for human consumption."
  {:added "1.0"
   :static true}
  [& more]
    (binding [*print-readably* nil]
      (apply pr more)))
</code>

Not everything is a function. Heck, sometimes you might not know what sort of thing you're looking at. But we can find out.
<code clojure-repl>
user=> (type 5)
java.lang.Long
user=> (type 5.2)
java.lang.Double
user=> (type "hello")
java.lang.String
user=> (type 'hello)
clojure.lang.Symbol
user=> (type {:a 5, :b 6})
clojure.lang.PersistentArrayMap
user=> (type [1 2 3])
clojure.lang.PersistentVector
user=> (type type)
clojure.core$type
user=> (type dir)
CompilerException java.lang.RuntimeException: Can't take value of a macro: #'clojure.repl/dir, compiling:(/tmp/form-init5987247545872948247.clj:1:1) 
user=> (type clojure.string/split)
clojure.string$split
user=> (defn say-hi [] (println "hi!"))
#'user/say-hi
user=> (type say-hi)
user$say_hi
</code>

== Getting GUI ==

Clojure comes with clojure.inspector, which gives some Swing GUI for exporing data structures.
<code clojure-repl>
user=> (use 'clojure.inspector)
user=> (inspect-tree {:a 1 :b 2 :c [1 2 3 {:d 4 :e 5 :f [6 7 8]}]})
</code>

NOTE: I had to do this to get jdk-1.7 swing apps to display while using xmonad (and other tiling window managers I guess). I now dropped this in my ~/.zshrc. Uhg.
<code clojure-repl>
export _JAVA_AWT_WM_NONREPARENTING=1
</code>


