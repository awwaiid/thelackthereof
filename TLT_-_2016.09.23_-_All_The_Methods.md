---
title: TLT_-_2016.09.23_-_All_The_Methods
createdAt: 2016-09-14T21:43-04:00
editedAt: 2016-09-17T16:12-04:00
---

A fun thing to do is to explore things using [https://en.wikipedia.org/wiki/Type_introspection Introspection]/[https://en.wikipedia.org/wiki/Reflection_(computer_programming) reflection]. In Ruby and Perl 6 (P6), for example, we can get a list of methods for a given object instance pretty easily:

<code>
# Ruby
"hello good people!".methods.each { |method| puts method.to_s }

# P6
for "hello good people!".^methods -> $method { say $method }
</code>

On the REPL (irb/pry or perl6) this is even shorter since it prints out lists of things by default, so you can do:

<code>
# Ruby
"hello good people!".methods

# P6
"hello good people!".^methods
</code>

One difference you see here is that P6 has a separate way to call meta-methods, whereas Ruby provides them directly. In some other languages you need to call into a separate reflection library and give it your object and what you want from it.

Cool!

This is a great and devious way to answer the question "what can I do with this object?". In Ruby's pry you can use the "ls" command like "ls foo" to get an even prettier version.

But you know... why stop there? Let's call them. All of them.

In P6 that looks like:
<code>
sub all-the-methods($thing) {
  for $thing.^methods -> $method {
    say "{$method.gist} => {$thing.clone.$method.gist}";
    CATCH { default { say "{$method.gist} => ERROR" } }
  }
}

all-the-methods <this is words>;
all-the-methods "hello little fishies!";
</code>

Taking the list of methods, we loop over them and invoke them one at a time. Here we do ".clone" so that if it is a mutating function we'll work on a copy. Note that ".clone" is NOT a deep-copy, so while it works in my simple list and string examples it might not work so well for other things. The call to .gist gives us a nice printable version of the result.

We invoke the method with no parameters, and many methods don't like that. So here we provide a CATCH block that just prints out a generic message -- it's inside the loop so after catching an error it'll just go to the next method.

In Ruby this looks like:
<code>
def all_the_methods(thing)
  thing.methods.each do |method|
    begin
      if method =~ /^pry|byebug|debugger$/
        puts "#{method} => SKIPPING"
        next
      end
      puts "#{method} => #{ thing.clone.send(method) }"
    rescue
      puts "#{method} => ERROR"
    end
  end
end

all_the_methods %w(this is words)
all_the_methods "hello little fishies!"
</code>

Here we had to explicitly skip the pry/byebug things, at least for my REPL execution, because those entered a subshell which isn't what I'm going for. Similar to P6 we also clone the object (also a shallow-clone) and had to handle exceptions, which are again almost entirely from methods that take more than zero parameters. In Ruby interpolated values automatically get .to_s called on them, so we don't need to do anything there.

One very notable thing is that operators in Ruby are methods directly on the object! This is nice for lots of reasons, including that you can easily override them. In P6 operators are standalone subs that do typed multi-dispatch (pattern matching) to decide what to execute, so the code isn't usually directly part of the class itself even if it ends up calling methods on the class or messing with the state.






